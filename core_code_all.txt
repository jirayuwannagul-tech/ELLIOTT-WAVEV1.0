===== app/analysis/__init__.py =====

===== app/analysis/context_gate.py =====
from typing import Dict, Optional

def apply_context_gate(
    scenario: Dict,
    macro_bias: Dict,
    min_confidence: float = 60.0,
) -> Optional[Dict]:
    """
    Gate layer (Strict Trend-Following - Option A):
    - ตัดสวน macro trend ทิ้ง
    - ตัด confidence ต่ำกว่า threshold
    - แนบ debug fields: allowed/reason/context_score (แต่ยังคืน scenario เดิม)
    """

    direction = (scenario.get("direction") or "").upper()
    conf = float(scenario.get("confidence") or scenario.get("score") or 0)

    # --- ใช้โครง macro_bias ที่มีอยู่ในระบบคุณ ---
    bias = (macro_bias.get("bias") or "NEUTRAL").upper()
    bias_strength = float(macro_bias.get("strength") or 0)
    allow_long = bool(macro_bias.get("allow_long", True))
    allow_short = bool(macro_bias.get("allow_short", True))

    allowed = True
    reason = ""

    # ---- confidence filter ----
    if conf < min_confidence:
        allowed = False
        reason = f"LOW_CONF({conf})"

    # ---- macro direction filter (Strict) ----
    if direction == "LONG" and not allow_long:
        allowed = False
        reason = f"BLOCKED_BY_MACRO({bias})"
    if direction == "SHORT" and not allow_short:
        allowed = False
        reason = f"BLOCKED_BY_MACRO({bias})"

    # ---- context score ----
    context_score = round((conf * 0.7) + (bias_strength * 0.3), 2)

    # ❌ ถ้าไม่ผ่าน: คืน None ให้ wave_engine ตัดทิ้ง
    if not allowed:
        return None

    # ✅ ถ้าผ่าน: คืน “scenario เดิม” + แนบฟิลด์ debug
    out = dict(scenario)
    out["allowed"] = True
    out["gate_reason"] = reason
    out["context_score"] = context_score
    return out
===== app/analysis/fib.py =====
def fib_retracement(start: float, end: float, current: float):
    move = end - start
    if move == 0:
        return None
    retrace = (current - end) / move

    # ถ้า retrace เกิน 1.0 = ราคากลับเกินจุดเริ่มต้น Wave1 → invalid
    if retrace > 1.0:
        return None

    # ถ้าติดลบ = ยังไม่ได้ retrace เลย → invalid
    if retrace < 0:
        return None

    return retrace

def fib_extension(a: float, b: float, c: float):
    """
    Calculate Fibonacci extension targets
    Wave A = a -> b
    Wave B = retrace to c
    """

    length = b - a

    targets = {
        "1.0": c + length,
        "1.618": c + (length * 1.618),
        "2.0": c + (length * 2.0),
    }

    return targets


def fib_zone_match(value: float):
    """
    Check which common fib zone the value fits
    """

    zones = {
        "0.236": 0.236,
        "0.382": 0.382,
        "0.5": 0.5,
        "0.618": 0.618,
        "0.786": 0.786,
        "1.0": 1.0,
        "1.618": 1.618,
    }

    tolerance = 0.03  # 3%

    matches = []

    for name, level in zones.items():
        if abs(value - level) <= tolerance:
            matches.append(name)

    return matches
===== app/analysis/macro_bias.py =====
# app/analysis/macro_bias.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict


@dataclass
class MacroBias:
    bias: str          # "LONG" | "SHORT" | "NEUTRAL"
    strength: float    # 0-100
    allow_long: bool
    allow_short: bool
    notes: str = ""


def _clamp(x: float, lo: float = 0.0, hi: float = 100.0) -> float:
    return max(lo, min(float(x), hi))


def compute_macro_bias(regime: Dict, rsi14: float = 50.0) -> Dict:
    """
    Input:
      - regime: dict จาก detect_market_regime()
      - rsi14: ค่า RSI ล่าสุด (ใช้ยืนยันโมเมนตัมแบบเบา ๆ)

    Output:
      - dict MacroBias พร้อม allow_long/allow_short สำหรับ gate
    """
    rg = (regime or {}).get("regime", "CHOP")
    tr = (regime or {}).get("trend", "NEUTRAL")
    vol = (regime or {}).get("vol", "MID")

    trend_strength = float((regime or {}).get("trend_strength", 0) or 0)
    vol_score = float((regime or {}).get("vol_score", 0) or 0)
    rsi14 = float(rsi14 or 50.0)

    bias = "NEUTRAL"
    strength = 0.0

    # ---- core bias from trend ----
    if rg == "TREND":
        if tr == "BULL":
            bias = "LONG"
            strength = 55.0 + (trend_strength * 0.35)
            if rsi14 >= 55:
                strength += 5.0
        elif tr == "BEAR":
            bias = "SHORT"
            strength = 55.0 + (trend_strength * 0.35)
            if rsi14 <= 45:
                strength += 5.0
        else:
            bias = "NEUTRAL"
            strength = 35.0

    elif rg == "RANGE":
        # range: ไม่ bias แรง ให้ neutral เป็นหลัก
        bias = "NEUTRAL"
        strength = 35.0
        # แต่ถ้า rsi เอียงชัด ก็ให้ bias เบา ๆ
        if rsi14 >= 60:
            bias = "LONG"
            strength = 45.0
        elif rsi14 <= 40:
            bias = "SHORT"
            strength = 45.0

    else:  # CHOP
        bias = "NEUTRAL"
        strength = 25.0
        # chop + vol สูง => ระวังสุด
        if vol == "HIGH":
            strength -= 5.0

    # ---- volatility penalty (กันมั่วใน vol สูง) ----
    # vol_score: LOW 25 / MID 55 / HIGH 80 (จาก market_regime)
    if vol_score >= 75:
        strength -= 8.0
    elif vol_score <= 30:
        strength += 3.0

    strength = _clamp(strength)

    # ---- allow gates ----
    # กติกา: ถ้า bias ชัด (>=60) ให้ “ปิดฝั่งสวน” เลย
    allow_long = True
    allow_short = True

    if bias == "LONG" and strength >= 60:
        allow_short = False
    if bias == "SHORT" and strength >= 60:
        allow_long = False

    mb = MacroBias(
        bias=bias,
        strength=round(strength, 2),
        allow_long=allow_long,
        allow_short=allow_short,
        notes=f"rg={rg} tr={tr} vol={vol} rsi={rsi14:.1f} ts={trend_strength:.1f} vs={vol_score:.1f}",
    )
    return mb.__dict__
===== app/analysis/market_regime.py =====
# app/analysis/market_regime.py
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional

import pandas as pd


@dataclass
class MarketRegime:
    regime: str              # "TREND" | "RANGE" | "CHOP"
    trend: str               # "BULL" | "BEAR" | "NEUTRAL"
    vol: str                 # "LOW" | "MID" | "HIGH"
    trend_strength: float    # 0-100 (คร่าว ๆ)
    vol_score: float         # 0-100 (คร่าว ๆ)
    notes: str = ""


def _safe_float(x, default: float = 0.0) -> float:
    try:
        v = float(x)
        return v
    except Exception:
        return default


def _pct(a: float, b: float) -> float:
    # percent diff of a vs b, guard b=0
    b = float(b)
    if b == 0:
        return 0.0
    return abs((float(a) - b) / b) * 100.0


def detect_market_regime(
    df: pd.DataFrame,
    ema_fast_col: str = "ema50",
    ema_slow_col: str = "ema200",
    atr_col: str = "atr14",
    rsi_col: str = "rsi14",
) -> Dict:
    """
    ต้องมีคอลัมน์: close, ema50, ema200, atr14, rsi14 (ตาม pipeline ปัจจุบันของคุณ)
    คืน dict ที่เอาไปใช้ gate/score ต่อได้ทันที
    """

    if df is None or len(df) < 250:
        mr = MarketRegime(
            regime="CHOP",
            trend="NEUTRAL",
            vol="MID",
            trend_strength=0.0,
            vol_score=0.0,
            notes="len<250",
        )
        return mr.__dict__

    last = df.iloc[-1]
    prev = df.iloc[-2] if len(df) >= 2 else last

    close = _safe_float(last.get("close"))
    ema_fast = _safe_float(last.get(ema_fast_col))
    ema_slow = _safe_float(last.get(ema_slow_col))
    atr = _safe_float(last.get(atr_col))
    rsi = _safe_float(last.get(rsi_col), 50.0)

    # -------- Trend direction (macro-ish) ----------
    # ใช้ระยะห่าง EMA + slope คร่าว ๆ
    ema_gap_pct = _pct(ema_fast, ema_slow)  # % ระยะห่างระหว่าง ema50 กับ ema200
    ema_fast_prev = _safe_float(prev.get(ema_fast_col), ema_fast)
    ema_slow_prev = _safe_float(prev.get(ema_slow_col), ema_slow)

    fast_slope = ema_fast - ema_fast_prev
    slow_slope = ema_slow - ema_slow_prev

    trend = "NEUTRAL"
    if ema_fast > ema_slow and fast_slope >= 0:
        trend = "BULL"
    elif ema_fast < ema_slow and fast_slope <= 0:
        trend = "BEAR"

    # -------- Volatility ----------
    # ATR เป็นหน่วยราคา → ทำให้เป็น % ของ close
    atr_pct = (atr / close * 100.0) if close else 0.0

    # แปลงเป็น vol_score 0-100 แบบง่าย (พอใช้ gate)
    # 1% = ต่ำ, 2.5% = กลาง, 4%+ = สูง (ปรับได้ทีหลัง)
    if atr_pct <= 1.2:
        vol = "LOW"
        vol_score = 25.0
    elif atr_pct <= 2.8:
        vol = "MID"
        vol_score = 55.0
    else:
        vol = "HIGH"
        vol_score = 80.0

    # -------- Regime (TREND / RANGE / CHOP) ----------
    # หลักง่าย: ถ้า EMA gap ใหญ่ + slope ไปทางเดียวกัน -> TREND
    # ถ้า gap เล็ก + RSI กลาง ๆ -> RANGE
    # นอกนั้น -> CHOP
    same_slope_dir = (fast_slope >= 0 and slow_slope >= 0) or (fast_slope <= 0 and slow_slope <= 0)

    trend_strength = 0.0
    # strength คร่าว ๆ จาก gap + slope + RSI bias
    trend_strength += min(ema_gap_pct * 10.0, 60.0)  # gap 6% -> +60
    trend_strength += 20.0 if same_slope_dir else 0.0
    if trend == "BULL":
        trend_strength += 10.0 if rsi >= 55 else 0.0
    elif trend == "BEAR":
        trend_strength += 10.0 if rsi <= 45 else 0.0
    trend_strength = max(0.0, min(trend_strength, 100.0))

    regime = "CHOP"
    if ema_gap_pct >= 1.0 and same_slope_dir:
        regime = "TREND"
    elif ema_gap_pct <= 0.5 and 45.0 <= rsi <= 55.0:
        regime = "RANGE"

    mr = MarketRegime(
        regime=regime,
        trend=trend,
        vol=vol,
        trend_strength=round(trend_strength, 2),
        vol_score=round(vol_score, 2),
        notes=f"ema_gap={ema_gap_pct:.2f}% atr%={atr_pct:.2f} rsi={rsi:.1f}",
    )
    return mr.__dict__
===== app/analysis/multi_tf.py =====
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, Optional, Tuple

import pandas as pd
import logging
logger = logging.getLogger(__name__)

from app.data.binance_fetcher import fetch_ohlcv, drop_unclosed_candle
from app.indicators.ema import add_ema
from app.indicators.rsi import add_rsi
from app.indicators.atr import add_atr
from app.indicators.trend_filter import trend_filter_ema
from app.analysis.pivot import find_fractal_pivots, filter_pivots


@dataclass
class MTFSummary:
    symbol: str
    weekly_trend: str        # BULL/BEAR/NEUTRAL
    h4_trend: str            # BULL/BEAR/NEUTRAL
    weekly_permit_long: bool
    weekly_permit_short: bool
    h4_confirm_long: bool
    h4_confirm_short: bool
    notes: str = ""


def _prepare_df(symbol: str, interval: str, limit: int) -> pd.DataFrame:
    df = fetch_ohlcv(symbol, interval=interval, limit=limit)
    df = drop_unclosed_candle(df)
    if df is None or len(df) == 0:
        return pd.DataFrame()

    # Indicators needed
    df = add_ema(df, lengths=(50, 200))
    df = add_rsi(df, length=14)
    df = add_atr(df, length=14)
    return df


def _last_close(df: pd.DataFrame) -> Optional[float]:
    try:
        return float(df["close"].iloc[-1])
    except Exception:
        return None


def _h4_structure_confirm(df4h: pd.DataFrame) -> Tuple[bool, bool, str]:
    """
    Confirm แบบง่าย (ไม่ยาว):
    - LONG confirm: close > last pivot-high price
    - SHORT confirm: close < last pivot-low price
    """
    if df4h is None or len(df4h) < 250:
        logger.warning(f"4H data ไม่พอ (len={len(df4h) if df4h is not None else 0}) → h4_confirm=False")
        return False, False, "4H len<250"

    close = _last_close(df4h)
    if close is None:
        return False, False, "4H no close"

    pivots = find_fractal_pivots(df4h, left=2, right=2)
    pivots = filter_pivots(pivots, min_pct_move=0.8)  # 4H ลด threshold เพื่อไม่ให้โล่ง

    lastH = None
    lastL = None
    for p in reversed(pivots):
        if lastH is None and p.get("type") == "H":
            lastH = float(p.get("price"))
        if lastL is None and p.get("type") == "L":
            lastL = float(p.get("price"))
        if lastH is not None and lastL is not None:
            break

    if lastH is None or lastL is None:
        logger.warning(f"4H pivots ไม่พอ → h4_confirm=False")
        return False, False, "4H pivots not enough"

    confirm_long = close > lastH
    confirm_short = close < lastL
    return confirm_long, confirm_short, f"4H close={close:.2f} lastH={lastH:.2f} lastL={lastL:.2f}"


def get_mtf_summary(
    symbol: str,
    weekly_limit: int = 300,
    h4_limit: int = 800,
) -> Dict:
    """
    1W = permit direction
    4H = confirm entry
    """

    dfw = _prepare_df(symbol, "1w", weekly_limit)
    df4 = _prepare_df(symbol, "4h", h4_limit)

    if dfw is None or len(dfw) < 250:
        logger.warning(f"[{symbol}] MTF weekly data ไม่พอ (len={len(dfw) if dfw is not None else 0}) → permit both, h4 skip")
        s = MTFSummary(
            symbol=symbol,
            weekly_trend="NEUTRAL",
            h4_trend="NEUTRAL",
            weekly_permit_long=True,
            weekly_permit_short=True,
            h4_confirm_long=False,
            h4_confirm_short=False,
            notes="weekly len<250",
        )
        return s.__dict__

    weekly_trend = trend_filter_ema(dfw)
    h4_trend = trend_filter_ema(df4) if (df4 is not None and len(df4) >= 250) else "NEUTRAL"

    # Strict permit: 1W BULL => long only, 1W BEAR => short only, NEUTRAL => both
    weekly_permit_long = True
    weekly_permit_short = True
    if weekly_trend == "BULL":
        weekly_permit_short = False
    elif weekly_trend == "BEAR":
        weekly_permit_long = False

    # 4H confirm
    h4_confirm_long, h4_confirm_short, note4 = _h4_structure_confirm(df4)

    s = MTFSummary(
        symbol=symbol,
        weekly_trend=weekly_trend,
        h4_trend=h4_trend,
        weekly_permit_long=weekly_permit_long,
        weekly_permit_short=weekly_permit_short,
        h4_confirm_long=h4_confirm_long,
        h4_confirm_short=h4_confirm_short,
        notes=note4,
    )
    return s.__dict__

===== app/analysis/pivot.py =====
import pandas as pd


def find_fractal_pivots(df: pd.DataFrame, left: int = 2, right: int = 2):
    """
    Detect fractal pivots (2-2 by default)
    Returns list of dict:
    {
        "index": int,
        "price": float,
        "type": "H" or "L"
    }

    หมายเหตุ: แต่ละแท่งได้ pivot ได้แค่ 1 ประเภท (H หรือ L)
    ถ้าเป็นได้ทั้งคู่ (เช่น doji ใหญ่) → เลือกฝั่งที่ move ห่างจาก prev_close มากกว่า
    """

    pivots = []

    for i in range(left, len(df) - right):
        high_slice = df["high"].iloc[i - left : i + right + 1]
        low_slice = df["low"].iloc[i - left : i + right + 1]

        current_high = float(df["high"].iloc[i])
        current_low = float(df["low"].iloc[i])

        is_pivot_high = current_high == high_slice.max()
        is_pivot_low = current_low == low_slice.min()

        # ✅ กัน H+L บนแท่งเดียวกัน
        # ถ้าเป็นได้ทั้งคู่ → เลือกฝั่งที่ move ห่างจาก prev_close มากกว่า
        if is_pivot_high and is_pivot_low:
            prev_close = float(df["close"].iloc[i - 1])
            high_move = abs(current_high - prev_close)
            low_move = abs(current_low - prev_close)

            if high_move >= low_move:
                is_pivot_low = False   # เลือก H
            else:
                is_pivot_high = False  # เลือก L

        if is_pivot_high:
            pivots.append(
                {
                    "index": i,
                    "price": current_high,
                    "type": "H",
                }
            )
        elif is_pivot_low:
            pivots.append(
                {
                    "index": i,
                    "price": current_low,
                    "type": "L",
                }
            )

    return pivots


def filter_pivots(pivots, min_pct_move: float = 0.5):
    """
    Remove small noisy pivots
    min_pct_move = minimum % difference between pivots
    """

    if not pivots:
        return []

    filtered = [pivots[0]]

    for pivot in pivots[1:]:
        last = filtered[-1]

        move_pct = abs((pivot["price"] - last["price"]) / last["price"]) * 100

        if move_pct >= min_pct_move:
            filtered.append(pivot)

    return filtered
===== app/analysis/trend_detector.py =====
def detect_market_mode(df):
    """
    แยกตลาดเป็น TREND หรือ SIDEWAY แบบง่าย
    ใช้ EMA50 / EMA200 + ATR
    """

    if "ema50" not in df.columns or "ema200" not in df.columns:
        return "TREND"

    ema50 = float(df["ema50"].iloc[-1])
    ema200 = float(df["ema200"].iloc[-1])
    atr = float(df["atr14"].iloc[-1]) if "atr14" in df.columns else 0.0
    price = float(df["close"].iloc[-1])

    # ถ้า EMA ใกล้กันมาก + ATR ต่ำ → sideway
    ema_gap_pct = abs(ema50 - ema200) / price * 100

    if ema_gap_pct < 0.5 and atr / price < 0.02:
        return "SIDEWAY"

    return "TREND"
===== app/analysis/wave_engine.py =====
from __future__ import annotations

from typing import Dict, List, Optional
import logging
logger = logging.getLogger(__name__)

import pandas as pd

from app.data.binance_fetcher import fetch_ohlcv, drop_unclosed_candle
from app.analysis.pivot import find_fractal_pivots, filter_pivots
from app.analysis.wave_scenarios import build_scenarios
from app.risk.risk_manager import build_trade_plan

from app.config.wave_settings import BARS, TIMEFRAME, MIN_RR, MIN_CONFIDENCE_LIVE

from app.indicators.ema import add_ema
from app.indicators.rsi import add_rsi
from app.indicators.atr import add_atr
from app.indicators.volume import add_volume_ma, volume_spike
from app.indicators.trend_filter import trend_filter_ema, allow_direction

from app.analysis.wave_labeler import label_pivot_chain
from app.analysis.context_gate import apply_context_gate
from app.analysis.market_regime import detect_market_regime
from app.analysis.macro_bias import compute_macro_bias
from app.analysis.multi_tf import get_mtf_summary
from app.analysis.zones import build_zones_from_pivots, nearest_support_resist
from app.analysis.trend_detector import detect_market_mode


def _safe_float(x, default: float = 0.0) -> float:
    try:
        return float(x)
    except Exception:
        return default

def _range_levels(df: pd.DataFrame, lookback: int = 60) -> Dict:
    """คำนวณกรอบ sideway แบบง่ายจาก lookback ล่าสุด"""
    if df is None or len(df) < max(lookback, 20):
        return {"range_low": None, "range_high": None, "atr": None}

    sub = df.iloc[-lookback:].copy()
    range_low = _safe_float(sub["low"].min(), 0.0)
    range_high = _safe_float(sub["high"].max(), 0.0)

    atr = None
    if "atr14" in sub.columns:
        atr = _safe_float(sub["atr14"].iloc[-1], 0.0)

    return {
        "range_low": float(range_low) if range_low else None,
        "range_high": float(range_high) if range_high else None,
        "atr": float(atr) if atr else None,
    }


def run_sideway_engine(symbol: str, df: pd.DataFrame, base: Dict) -> Dict:
    """
    SIDEWAY ENGINE (v0): mean-reversion ในกรอบ

    เงื่อนไขเข้าแบบง่าย:
    - LONG: ราคาใกล้ range_low + buffer และ RSI ต่ำ
    - SHORT: ราคาใกล้ range_high - buffer และ RSI สูง
    """
    base = dict(base or {})

    price = _safe_float(base.get("price"), 0.0)
    rsi14 = _safe_float(base.get("rsi14"), 50.0)
    weekly_permit_long = bool(base.get("weekly_permit_long", True))
    weekly_permit_short = bool(base.get("weekly_permit_short", True))

    lv = _range_levels(df, lookback=60)
    range_low = lv.get("range_low")
    range_high = lv.get("range_high")
    atr = lv.get("atr")

    base["sideway"] = {
        "range_low": range_low,
        "range_high": range_high,
        "atr": atr,
        "lookback": 60,
    }

    # ถ้าข้อมูลไม่พอ -> คืนแบบไม่ยิงสัญญาณ
    if not range_low or not range_high or range_high <= range_low:
        base["scenarios"] = []
        base["message"] = "SIDEWAY: ข้อมูลยังไม่พอคำนวณกรอบ"
        return base

    # buffer กันหลอก: ใช้ ATR ถ้ามี ไม่งั้นใช้ 0.5% ของราคา
    buffer = float(atr) * 0.5 if atr and atr > 0 else float(price) * 0.005

    near_support = price <= (range_low + buffer)
    near_resist = price >= (range_high - buffer)

    scenarios: List[Dict] = []

    # LONG near support + RSI low
    if near_support and rsi14 <= 45 and weekly_permit_long:
        sc = {
            "type": "SIDEWAY_RANGE",
            "phase": "MEAN_REVERT",
            "direction": "LONG",
            "probability": 0.0,
            "confidence": 65.0,
            # ✅ ADD
            "range_low": range_low,
            "range_high": range_high,
            "atr": atr,
            "reasons": [
                f"Near range low ({range_low:,.2f})",
                f"RSI14 low ({rsi14:.1f})",
            ],
        }
        plan = build_trade_plan(sc, current_price=price, min_rr=2.0)
        plan["triggered"] = True
        sc["trade_plan"] = plan
        scenarios.append(sc)

    # SHORT near resist + RSI high
    if near_resist and rsi14 >= 55 and weekly_permit_short:
        sc = {
            "type": "SIDEWAY_RANGE",
            "phase": "MEAN_REVERT",
            "direction": "SHORT",
            "probability": 0.0,
            "confidence": 65.0,
            # ✅ ADD
            "range_low": range_low,
            "range_high": range_high,
            "atr": atr,
            "reasons": [
                f"Near range high ({range_high:,.2f})",
                f"RSI14 high ({rsi14:.1f})",
            ],
        }
        plan = build_trade_plan(sc, current_price=price, min_rr=2.0)
        plan["triggered"] = True
        sc["trade_plan"] = plan
        scenarios.append(sc)

    base["scenarios"] = scenarios

    if scenarios:
        base["message"] = (
            f"SIDEWAY: พบ setup ในกรอบ ({range_low:,.2f} - {range_high:,.2f})"
        )
    else:
        base["message"] = (
            f"SIDEWAY: ยังไม่เข้าเงื่อนไข (กรอบ {range_low:,.2f} - {range_high:,.2f})"
        )

    return base


def analyze_symbol(symbol: str) -> Optional[Dict]:
    # 1) Fetch data (1D)
    df = fetch_ohlcv(symbol, interval=TIMEFRAME, limit=BARS)
    df = drop_unclosed_candle(df)

    if df is None or len(df) < 250:  # ต้องพอสำหรับ EMA200
        return None

    # 1.5) Add indicators (1D)
    df = add_ema(df, lengths=(50, 200))
    df = add_rsi(df, length=14)
    df = add_atr(df, length=14)
    df = add_volume_ma(df, length=20)

    last_close = float(df["close"].iloc[-1])
    current_price = last_close
    close_today = last_close
    close_yesterday = float(df["close"].iloc[-2]) if len(df) >= 2 else None

    macro_trend = trend_filter_ema(df)  # BULL/BEAR/NEUTRAL (1D)
    rsi14 = float(df["rsi14"].iloc[-1])
    is_vol_spike = bool(volume_spike(df, length=20, multiplier=1.5))

    # 1.6) Trend / Sideway mode
    mode = detect_market_mode(df)
    size_mult = 1.0 if mode == "TREND" else 0.5

    # 1.8) MTF summary (1W permit / 4H confirm)
    mtf = get_mtf_summary(symbol) or {}
    weekly_permit_long = bool(mtf.get("weekly_permit_long", True))
    weekly_permit_short = bool(mtf.get("weekly_permit_short", True))
    h4_confirm_long = bool(mtf.get("h4_confirm_long", False))
    h4_confirm_short = bool(mtf.get("h4_confirm_short", False))

    base = {
        "symbol": symbol,
        "price": current_price,
        "close_today": close_today,
        "close_yesterday": close_yesterday,
        "macro_trend": macro_trend,
        "rsi14": rsi14,
        "volume_spike": is_vol_spike,
        "mtf": mtf,
        "mode": mode,
        "position_size_mult": size_mult,
    }

    # SIDEWAY -> engine แยก
    if mode == "SIDEWAY":
        # ✅ FIX: ส่ง MTF permit เข้าไปด้วย
        base["weekly_permit_long"] = weekly_permit_long
        base["weekly_permit_short"] = weekly_permit_short
        return run_sideway_engine(symbol, df, base)

    # 2) Pivot detection (1D)
    pivots = find_fractal_pivots(df)
    pivots = filter_pivots(pivots, min_pct_move=1.5)
    wave_label = label_pivot_chain(pivots)

    # 2.5) Build SR zones from pivots
    zones = build_zones_from_pivots(df)
    sr = nearest_support_resist(zones, price=current_price)

    if len(pivots) < 4:
        out = dict(base)
        out.update({
            "scenarios": [],
            "message": "โครงสร้างยังไม่ชัด",
            "wave_label": wave_label,
            "sideway": None,
        "zones": zones if zones else [],
        "sr": sr if sr else {},
        })
        return out

    # 3) Build scenarios (top 3) (1D)
    scenarios = build_scenarios(
        pivots,
        macro_trend=macro_trend,
        rsi14=rsi14,
        volume_spike=is_vol_spike,
    )

    # 3.5) Context gate — ✅ FIX: ใช้ compute_macro_bias จริง ไม่ hardcode
    regime = detect_market_regime(df)
    macro_bias = compute_macro_bias(regime, rsi14=rsi14)

    gated_scenarios: List[Dict] = []
    for sc in (scenarios or []):
        gated = apply_context_gate(
            scenario=sc,
            macro_bias=macro_bias,
            min_confidence=MIN_CONFIDENCE_LIVE,
        )
        if isinstance(gated, dict) and gated.get("direction"):
            gated_scenarios.append(gated)

    scenarios = gated_scenarios

    results: List[Dict] = []

    # 4) Build trade plan per scenario
    for scenario in (scenarios or []):
        direction = (scenario.get("direction") or "").upper()
        if not direction:
            continue

        # --- MTF Gate (weekly permit) ---
        if direction == "LONG" and not weekly_permit_long:
            continue
        if direction == "SHORT" and not weekly_permit_short:
            continue

        # --- MTF Gate (4H confirm) ---
        mtf_ok = True
        if direction == "LONG" and not h4_confirm_long:
            mtf_ok = False
        if direction == "SHORT" and not h4_confirm_short:
            mtf_ok = False

        # ✅ FIX: เช็ค mtf_ok ก่อน build_trade_plan (เดิมเช็คผิดที่)
        if not mtf_ok:
            logger.info(
                f"[{symbol}] MTF block: direction={direction} "
                f"h4_confirm_long={h4_confirm_long} h4_confirm_short={h4_confirm_short} "
                f"notes={mtf.get('notes')}"
            )
            continue

        trade_plan = build_trade_plan(
            scenario,
            current_price=current_price,
            min_rr=float(MIN_RR) if MIN_RR else 3.0,
            sr=sr,
        )

        # Close-confirm trigger
        entry = trade_plan.get("entry")
        if entry is not None:
            entry = float(entry)
            stype = (scenario.get("type") or "").upper()
            if stype == "ABC_UP":
                trade_plan["triggered"] = last_close > float(trade_plan["sl"]) * 1.01
            elif stype == "ABC_DOWN":
                trade_plan["triggered"] = last_close < float(trade_plan["sl"]) * 0.99
            else:
                if direction == "LONG" and last_close <= entry:
                    trade_plan["triggered"] = False
                elif direction == "SHORT" and last_close >= entry:
                    trade_plan["triggered"] = False
                else:
                    trade_plan["triggered"] = True
        else:
            trade_plan["triggered"] = False

        trade_plan["volume_ok"] = is_vol_spike

        results.append({
            "type": scenario.get("type"),
            "phase": scenario.get("phase"),
            "direction": direction,
            "probability": scenario.get("probability"),
            "confidence": scenario.get("confidence"),
            "context_score": scenario.get("context_score"),
            "mtf_ok": mtf_ok,
            "trade_plan": trade_plan,
            "reasons": scenario.get("reasons", []),
        })

    msg = None
    if scenarios and not results:
        msg = (
            f"โดนกรองด้วย MTF/Trend/RSI/SNIPER "
            f"(1D={macro_trend}, rsi14={rsi14:.1f}, "
            f"1Wpermit(L/S)={weekly_permit_long}/{weekly_permit_short}, "
            f"4Hconfirm(L/S)={h4_confirm_long}/{h4_confirm_short})"
        )

    out = dict(base)
    out.update({
        "scenarios": results,
        "message": msg,
        "wave_label": wave_label,
        "sideway": None,
        "zones": zones if zones else [],
        "sr": sr if sr else {},
    })
    return out
===== app/analysis/wave_labeler.py =====
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

from app.analysis.wave_rules import validate_impulse, validate_abc


@dataclass
class WaveLabel:
    pattern: str               # "IMPULSE_LONG" / "IMPULSE_SHORT" / "ABC_UP" / "ABC_DOWN"
    direction: str             # "LONG" / "SHORT"
    start_index: int           # pivot-chain start (0-based in pivots list)
    end_index: int             # pivot-chain end
    pivot_count: int           # 6 for impulse, 4 for abc
    confidence: float          # 0-100 (ใช้ score แบบเบื้องต้นจากกฎที่ผ่าน)
    reasons: List[str]         # รายการเหตุผล/คำเตือน (ถ้ามี)
    pivots: List[Dict]         # pivots slice ที่ใช้


def _score_from_reasons(base: float, reasons: List[str]) -> float:
    # ยิ่งมี reasons มาก = ความมั่นใจลด (แต่ ABC อนุญาต warning ได้)
    score = float(base) - (len(reasons) * 5.0)
    if score < 1:
        score = 1.0
    if score > 100:
        score = 100.0
    return score


def label_pivot_chain(pivots: List[Dict]) -> Dict:
    """
    สแกน pivot chain ทั้งเส้น แล้วหา pattern ที่ "จบล่าสุด" (ใกล้ท้ายที่สุด)
    คืนค่า label เดียวที่ดีที่สุด (หรือ None)
    - IMPULSE ใช้ 6 pivots
    - ABC ใช้ 4 pivots
    """

    if not pivots or len(pivots) < 4:
        return {"label": None, "matches": []}

    matches: List[WaveLabel] = []

    # --- Scan IMPULSE windows (6 pivots) ---
    if len(pivots) >= 6:
        for i in range(0, len(pivots) - 6 + 1):
            window = pivots[i : i + 6]

            okL, reasonsL = validate_impulse(window, "LONG")
            if okL:
                matches.append(
                    WaveLabel(
                        pattern="IMPULSE_LONG",
                        direction="LONG",
                        start_index=i,
                        end_index=i + 5,
                        pivot_count=6,
                        confidence=_score_from_reasons(85.0, reasonsL),
                        reasons=reasonsL,
                        pivots=window,
                    )
                )

            okS, reasonsS = validate_impulse(window, "SHORT")
            if okS:
                matches.append(
                    WaveLabel(
                        pattern="IMPULSE_SHORT",
                        direction="SHORT",
                        start_index=i,
                        end_index=i + 5,
                        pivot_count=6,
                        confidence=_score_from_reasons(85.0, reasonsS),
                        reasons=reasonsS,
                        pivots=window,
                    )
                )

    # --- Scan ABC windows (4 pivots) ---
    for i in range(0, len(pivots) - 4 + 1):
        window = pivots[i : i + 4]

        okD, reasonsD = validate_abc(window, "DOWN")
        if okD:
            matches.append(
                WaveLabel(
                    pattern="ABC_DOWN",
                    direction="SHORT",
                    start_index=i,
                    end_index=i + 3,
                    pivot_count=4,
                    confidence=_score_from_reasons(65.0, reasonsD),
                    reasons=reasonsD,
                    pivots=window,
                )
            )

        okU, reasonsU = validate_abc(window, "UP")
        if okU:
            matches.append(
                WaveLabel(
                    pattern="ABC_UP",
                    direction="LONG",
                    start_index=i,
                    end_index=i + 3,
                    pivot_count=4,
                    confidence=_score_from_reasons(65.0, reasonsU),
                    reasons=reasonsU,
                    pivots=window,
                )
            )

    if not matches:
        return {"label": None, "matches": []}

    # เลือก "จบล่าสุด" ก่อน (end_index มากสุด) แล้วค่อยตัดสินด้วย confidence
    matches.sort(key=lambda m: (m.end_index, m.confidence), reverse=True)
    best = matches[0]

    # ทำผลลัพธ์ให้อ่านง่าย
    label = {
        "pattern": best.pattern,
        "direction": best.direction,
        "start_pivot_i": best.start_index,
        "end_pivot_i": best.end_index,
        "pivot_count": best.pivot_count,
        "confidence": round(float(best.confidence), 1),
        "reasons": best.reasons,
        # ✅ ส่ง pivot prices มาด้วย (ย่อ)
        "pivots": [
            {
                "index": int(p.get("index")),
                "type": p.get("type"),
                "price": float(p.get("price")),
            }
            for p in (best.pivots or [])
        ],
    }

    return {"label": label, "matches": matches}

===== app/analysis/wave_rules.py =====
from typing import Dict, List, Tuple
from app.analysis.fib import fib_retracement, fib_extension, fib_zone_match


def _is_alternating_types(points: List[Dict]) -> bool:
    """Ensure pivot types alternate L/H/L/H... or H/L/H/L..."""
    if len(points) < 2:
        return False
    for i in range(1, len(points)):
        if points[i]["type"] == points[i - 1]["type"]:
            return False
    return True


def _price(points: List[Dict], i: int) -> float:
    return float(points[i]["price"])


def validate_impulse(points: List[Dict], direction: str) -> Tuple[bool, List[str]]:
    """
    Validate Elliott Impulse 1-5 using 6 pivots (0..5) representing:
    LONG  : L0-H1-L2-H3-L4-H5
    SHORT : H0-L1-H2-L3-H4-L5

    direction: "LONG" or "SHORT"
    Returns (pass, reasons)
    """
    reasons: List[str] = []
    direction = (direction or "").upper().strip()

    if len(points) != 6:
        return False, ["Impulse ต้องใช้ pivot 6 จุด (0..5)"]

    if not _is_alternating_types(points):
        return False, ["ชนิด pivot ไม่สลับ H/L ต่อเนื่อง"]

    # Assign pivots
    p0, p1, p2, p3, p4, p5 = points

    if direction == "LONG":
        expected = ["L", "H", "L", "H", "L", "H"]
    elif direction == "SHORT":
        expected = ["H", "L", "H", "L", "H", "L"]
    else:
        return False, ["direction ต้องเป็น LONG หรือ SHORT"]

    if [p["type"] for p in points] != expected:
        return False, [f"Impulse {direction} ต้องเป็น pattern {''.join(expected)}"]

    # Rule 1: Wave 2 must not retrace beyond start of Wave 1
    # LONG: p2 must be above p0
    # SHORT: p2 must be below p0
    if direction == "LONG":
        if _price(points, 2) <= _price(points, 0):
            reasons.append("ผิดกฎ: Wave2 หลุดจุดเริ่ม Wave1 (invalid)")
    else:
        if _price(points, 2) >= _price(points, 0):
            reasons.append("ผิดกฎ: Wave2 หลุดจุดเริ่ม Wave1 (invalid)")

    # Rule 2: Wave 3 must not be the shortest among 1,3,5
    # Measure wave lengths by absolute price move
    w1 = abs(_price(points, 1) - _price(points, 0))
    w3 = abs(_price(points, 3) - _price(points, 2))
    w5 = abs(_price(points, 5) - _price(points, 4))

    if w3 <= min(w1, w5):
        reasons.append("ผิดกฎ: Wave3 สั้นสุด (invalid)")

    # Rule 3: Wave 4 must not overlap Wave 1 (classic impulse)
    # LONG: wave4 low (p4) must be above wave1 high (p1)
    # SHORT: wave4 high (p4) must be below wave1 low (p1)
    if direction == "LONG":
        if _price(points, 4) <= _price(points, 1):
            reasons.append("ผิดกฎ: Wave4 overlap Wave1 (invalid)")
    else:
        if _price(points, 4) >= _price(points, 1):
            reasons.append("ผิดกฎ: Wave4 overlap Wave1 (invalid)")

    # ---- Fibonacci validation ----
    # Wave2 retracement (ต้องกันหารศูนย์)
    if direction == "LONG":
        wave1_len = _price(points, 1) - _price(points, 0)
    else:
        wave1_len = _price(points, 0) - _price(points, 1)

    if wave1_len == 0:
        reasons.append("Wave1 length = 0 (คำนวณ Fib ไม่ได้)")
    else:
        wave2_retrace = fib_retracement(_price(points, 0), _price(points, 1), _price(points, 2))
        if wave2_retrace is None or not fib_zone_match(wave2_retrace):
            reasons.append("Wave2 retrace ไม่อยู่ในช่วง 0.382–0.786")

        # Wave3 extension
        wave3_targets = fib_extension(_price(points, 0), _price(points, 1), _price(points, 2))
        wave3_ext = w3 / abs(wave1_len)
        if wave3_ext < 1.0:
            reasons.append("Wave3 extension < 1.0 (อ่อนเกิน)")

    ok = len(reasons) == 0
    return ok, reasons


def validate_abc(points: List[Dict], direction: str) -> Tuple[bool, List[str]]:
    """
    Basic ABC correction validation using 4 pivots (0..3):
    For bearish correction after uptrend (down A, up B, down C) etc.
    เราเช็คแค่ pattern + ความต่อเนื่องก่อน (ไม่ลงลึกชนิด zigzag/flat/triangle ในไฟล์นี้)

    direction:
      - "DOWN" = A ลง, B ขึ้น, C ลง (L/H/L pattern end)
      - "UP"   = A ขึ้น, B ลง, C ขึ้น
    """
    reasons: List[str] = []
    direction = (direction or "").upper().strip()

    if len(points) != 4:
        return False, ["ABC ต้องใช้ pivot 4 จุด (0..3)"]

    if not _is_alternating_types(points):
        return False, ["ชนิด pivot ไม่สลับ H/L ต่อเนื่อง"]

    p0, p1, p2, p3 = points

    if direction == "DOWN":
        # H0-L1-H2-L3
        expected = ["H", "L", "H", "L"]
        if [p["type"] for p in points] != expected:
            return False, [f"ABC DOWN ต้องเป็น pattern {''.join(expected)}"]
        # C should make a lower low than A (often), allow equal with tolerance later
        if _price(points, 3) >= _price(points, 1):
            reasons.append("โครงสร้างไม่ชัด: C ไม่ทำ low ต่ำกว่า A (confidence ต่ำ)")
    elif direction == "UP":
        # L0-H1-L2-H3
        expected = ["L", "H", "L", "H"]
        if [p["type"] for p in points] != expected:
            return False, [f"ABC UP ต้องเป็น pattern {''.join(expected)}"]
        if _price(points, 3) <= _price(points, 1):
            reasons.append("โครงสร้างไม่ชัด: C ไม่ทำ high สูงกว่า A (confidence ต่ำ)")
    else:
        return False, ["direction ต้องเป็น UP หรือ DOWN"]

    # ABC ผ่านได้แม้ confidence ต่ำ (ให้ scoring ไปจัดใน wave_scenarios)

    # ---- ABC Fibonacci classification (basic) ----
    # ใช้ความยาว A และตำแหน่ง B เทียบ fib retrace
    a_len = abs(_price(points, 1) - _price(points, 0))
    if a_len == 0:
        reasons.append("Wave A length = 0 (คำนวณ Fib ไม่ได้)")
        return True, reasons

    # B retrace ratio จากจบ A กลับไปทาง A
    # DOWN: A = H0->L1, B = L1->H2
    # UP  : A = L0->H1, B = H1->L2
    b_retrace = abs((_price(points, 2) - _price(points, 1)) / a_len)

    # Classify แบบพื้นฐาน
    # Zigzag: B มัก retrace ~0.382–0.618
    # Flat:   B มัก retrace >= 0.8 (ใกล้ 0.9–1.0)
    if 0.382 <= b_retrace <= 0.618:
        reasons.append("ABC: คล้าย Zigzag (B retrace 0.382–0.618)")
    elif b_retrace >= 0.8:
        reasons.append("ABC: คล้าย Flat (B retrace >= 0.8)")
    else:
        reasons.append("ABC: B retrace ไม่ชัด (Zigzag/Flat ไม่ชัด)")

    # C extension (เทียบกับ A)
    c_len = abs(_price(points, 3) - _price(points, 2))
    c_ext = c_len / a_len
    if c_ext < 1.0:
        reasons.append("ABC: Wave C สั้นกว่า A (อ่อน)")
    elif c_ext >= 1.618:
        reasons.append("ABC: Wave C ยืดแรง (>=1.618)")
    return True, reasons

===== app/analysis/wave_scenarios.py =====
from typing import List, Dict
from app.analysis.wave_rules import validate_impulse, validate_abc


def score_scenario(base_score, warnings, macro_trend, rsi14, volume_spike, direction):
    """
    Scoring model (0-100)
    - base_score: strength from structure type
    - warnings: ลดคะแนนจาก rule/fib warnings
    - macro_trend/rsi/volume: เพิ่ม-ลดความมั่นใจ
    """
    score = float(base_score)

    # warning penalty
    score -= len(warnings) * 4

    # Trend bonus/penalty
    mt = (macro_trend or "NEUTRAL").upper()
    if mt == "NEUTRAL":
        score -= 2
    if mt in ("BULL", "BEAR"):
        score += 4

    # RSI bonus (only strong momentum)
    direction = (direction or "").upper()
    if direction == "LONG":
        if rsi14 >= 60:
            score += 4
        elif rsi14 >= 55:
            score += 2
    elif direction == "SHORT":
        if rsi14 <= 40:
            score += 4
        elif rsi14 <= 45:
            score += 2

    # Volume spike bonus
    if volume_spike:
        score += 5

    return max(min(score, 100), 1)


def normalize_scores(scenarios: List[Dict]) -> List[Dict]:
    total = sum(s["score"] for s in scenarios) or 1.0
    for s in scenarios:
        # ✅ FIX: เปลี่ยนชื่อเป็น relative_score แทน probability
        # เพราะนี่คือสัดส่วนคะแนนเทียบกัน ไม่ใช่ probability จริง
        s["relative_score"] = round((s["score"] / total) * 100, 1)
        s["probability"] = s["relative_score"]  # เก็บไว้กัน backward compat
        s["confidence"] = round(float(s["score"]), 1)
    return scenarios


def build_scenarios(
    pivots: List[Dict],
    macro_trend: str = "NEUTRAL",
    rsi14: float = 50.0,
    volume_spike: bool = False
) -> List[Dict]:
    scenarios = []

    # -------------------------
    # Scenario 1: Impulse LONG
    # -------------------------
    if len(pivots) >= 6:
        last6 = pivots[-6:]
        ok, warnings = validate_impulse(last6, "LONG")
        if ok and len(warnings) <= 1:

            scenarios.append({
                "type": "IMPULSE_LONG",
                "phase": "Wave 5 or continuation",
                "direction": "LONG",
                "score": score_scenario(85, warnings, macro_trend, rsi14, volume_spike, direction="LONG"),
                "reasons": warnings,
                "pivots": last6,
            })

    # -------------------------
    # Scenario 2: Impulse SHORT
    # -------------------------
    if len(pivots) >= 6:
        last6 = pivots[-6:]
        ok, warnings = validate_impulse(last6, "SHORT")
        if ok and len(warnings) <= 1:

            scenarios.append({
                "type": "IMPULSE_SHORT",
                "phase": "Wave 5 or continuation",
                "direction": "SHORT",
                "score": score_scenario(85, warnings, macro_trend, rsi14, volume_spike, direction="SHORT"),
                "reasons": warnings,
                "pivots": last6,
            })

    # -------------------------
    # Scenario 3: ABC Correction
    # -------------------------
    if len(pivots) >= 4:
        last4 = pivots[-4:]

        ok_down, warnings_down = validate_abc(last4, "DOWN")
        if ok_down and len(warnings_down) <= 1:
            scenarios.append({
                "type": "ABC_DOWN",
                "phase": "Wave C ลง",
                "direction": "SHORT",
                "score": score_scenario(65, warnings_down, macro_trend, rsi14, volume_spike, direction="SHORT"),
                "reasons": warnings_down,
                "pivots": last4,
            })

        ok_up, warnings_up = validate_abc(last4, "UP")
        if ok_up and len(warnings_up) <= 1:
            scenarios.append({
                "type": "ABC_UP",
                "phase": "Wave C ขึ้น",
                "direction": "LONG",
                "score": score_scenario(65, warnings_up, macro_trend, rsi14, volume_spike, direction="LONG"),
                "reasons": warnings_up,
                "pivots": last4,
            })

    if not scenarios:
        return []

    scenarios.sort(key=lambda x: x["score"], reverse=True)
    scenarios = scenarios[:3]
    scenarios = normalize_scores(scenarios)
    return scenarios
===== app/analysis/zones.py =====
from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

import pandas as pd

from app.analysis.pivot import find_fractal_pivots, filter_pivots


@dataclass
class Zone:
    kind: str            # "SR"
    level: float         # center price
    low: float           # zone low
    high: float          # zone high
    touches: int         # number of hits clustered
    side: str            # "SUPPORT" or "RESIST"
    notes: str = ""


def _safe_float(x, default: float = 0.0) -> float:
    try:
        return float(x)
    except Exception:
        return default


def _merge_clusters(levels: List[float], tol_pct: float) -> List[List[float]]:
    """
    cluster ราคาที่อยู่ใกล้กันภายใน tol_pct ของ level
    ใช้ center ของ cluster แรกเป็น anchor เพื่อป้องกัน cluster drift
    """
    if not levels:
        return []
    levels = sorted(float(x) for x in levels)
    clusters: List[List[float]] = [[levels[0]]]
    # FIX: เก็บ anchor (center เริ่มต้น) แยกต่างหาก
    anchors: List[float] = [levels[0]]

    for v in levels[1:]:
        anchor = anchors[-1]
        tol = abs(anchor) * (tol_pct / 100.0)
        if abs(v - anchor) <= tol:
            clusters[-1].append(v)
        else:
            clusters.append([v])
            anchors.append(v)

    return clusters


def build_zones_from_pivots(
    df: pd.DataFrame,
    min_pct_move: float = 1.5,
    tol_pct: float = 0.35,
    min_touches: int = 2,
    max_zones: int = 8,
) -> List[Dict]:
    """
    - หา pivots จาก fractal
    - เอา pivot prices มาคลัสเตอร์เป็นโซน
    - โซนที่ touches สูงจะสำคัญกว่า
    """
    if df is None or len(df) < 50:
        return []

    close = _safe_float(df["close"].iloc[-1], 0.0)

    pivots = find_fractal_pivots(df, left=2, right=2)
    pivots = filter_pivots(pivots, min_pct_move=min_pct_move)

    highs = [float(p["price"]) for p in pivots if p.get("type") == "H"]
    lows = [float(p["price"]) for p in pivots if p.get("type") == "L"]

    high_clusters = _merge_clusters(highs, tol_pct=tol_pct)
    low_clusters = _merge_clusters(lows, tol_pct=tol_pct)

    zones: List[Zone] = []

    def _cluster_to_zone(cluster: List[float], side: str) -> Optional[Zone]:
        if not cluster or len(cluster) < min_touches:
            return None

        center = sum(cluster) / len(cluster)
        # FIX: ใช้ lo/hi ตรง ๆ แทนการคำนวณซ้ำจาก spread
        lo = min(cluster)
        hi = max(cluster)
        # เผื่อ cluster มีแค่ 1 ค่า (กรณีผ่าน min_touches=1) ให้มี spread เล็กน้อย
        if hi == lo:
            margin = abs(center) * 0.0005
            lo = center - margin
            hi = center + margin

        return Zone(
            kind="SR",
            level=round(center, 6),
            low=round(lo, 6),
            high=round(hi, 6),
            touches=len(cluster),
            side=side,
            notes=f"cluster[{len(cluster)}]",
        )

    for c in high_clusters:
        z = _cluster_to_zone(c, side="RESIST")
        if z:
            zones.append(z)

    for c in low_clusters:
        z = _cluster_to_zone(c, side="SUPPORT")
        if z:
            zones.append(z)

    def _score(z: Zone) -> Tuple[int, float]:
        dist = abs(float(z.level) - close) if close else 1e9
        return (z.touches, -dist)

    zones.sort(key=_score, reverse=True)
    zones = zones[:max_zones]

    return [z.__dict__ for z in zones]


def nearest_support_resist(zones: list, price: float) -> dict:
    """
    คืน SR ใกล้สุดใต้/เหนือราคา
    ไม่เชื่อ side เดิม — คำนวณใหม่จากตำแหน่งราคา
    """
    price = float(price)

    below = []
    above = []

    for z in (zones or []):
        lvl = float(z.get("level", 0) or 0)
        # FIX: strict comparison เพื่อไม่ให้ level เดียวกับ price
        # ปรากฏในทั้ง support และ resist พร้อมกัน
        if lvl < price:
            below.append(z)
        elif lvl > price:
            above.append(z)

    below.sort(key=lambda z: abs(float(z.get("level", 0) or 0) - price))
    above.sort(key=lambda z: abs(float(z.get("level", 0) or 0) - price))

    sup = dict(below[0]) if below else None
    res = dict(above[0]) if above else None

    if sup:
        sup["side"] = "SUPPORT"
    if res:
        res["side"] = "RESIST"

    return {
        "support": sup,
        "resist": res,
    }
===== app/backtest/__init__.py =====

===== app/backtest/backtest_runner.py =====
from __future__ import annotations

import logging
from typing import Dict, List, Optional

import pandas as pd

from app.data.binance_fetcher import fetch_ohlcv, drop_unclosed_candle
from app.analysis.pivot import find_fractal_pivots, filter_pivots
from app.analysis.wave_scenarios import build_scenarios
from app.risk.risk_manager import build_trade_plan
from app.indicators.ema import add_ema
from app.indicators.rsi import add_rsi
from app.indicators.atr import add_atr
from app.indicators.volume import add_volume_ma, volume_spike
from app.indicators.trend_filter import trend_filter_ema, allow_direction
from app.analysis.context_gate import apply_context_gate
from app.analysis.market_regime import detect_market_regime
from app.analysis.macro_bias import compute_macro_bias
from app.config.wave_settings import MIN_CONFIDENCE_BACKTEST

logger = logging.getLogger(__name__)

# ---- constants ----
_START_BAR = 250
_EMPTY_BUCKETS = {
    "conf>=60": {"trades": 0, "wins": 0, "losses": 0, "open": 0, "winrate": 0.0},
    "conf>=70": {"trades": 0, "wins": 0, "losses": 0, "open": 0, "winrate": 0.0},
    "conf>=80": {"trades": 0, "wins": 0, "losses": 0, "open": 0, "winrate": 0.0},
}


# ---------------------------------------------------------------------------
# helpers
# ---------------------------------------------------------------------------

def _prepare_df(symbol: str, interval: str, limit: int) -> Optional[pd.DataFrame]:
    """Fetch + drop unclosed + add indicators. คืน None ถ้าข้อมูลไม่พอ"""
    df = fetch_ohlcv(symbol, interval=interval, limit=limit)
    df = drop_unclosed_candle(df)
    if df is None or len(df) < _START_BAR:
        return None
    df = add_ema(df, lengths=(50, 200))
    df = add_rsi(df, length=14)
    df = add_atr(df, length=14)
    df = add_volume_ma(df, length=20)
    return df


def _simulate_one_trade(
    df: pd.DataFrame,
    start_i: int,
    direction: str,
    entry: float,
    sl: float,
    tp1: float,
    tp2: float,
    tp3: float,
) -> Dict:
    """
    เดินแท่งจาก start_i ไปข้างหน้า จนเจอ SL หรือ TP3
    - เช็ค SL ก่อนเสมอ (conservative)
    - ถ้าครบ df โดยไม่เจอ SL/TP → OPEN
    """
    for i in range(start_i, len(df)):
        high = float(df["high"].iloc[i])
        low = float(df["low"].iloc[i])

        if direction == "LONG":
            if low <= sl:
                return {"result": "LOSS", "exit": sl, "bars": i - start_i}
            if high >= tp3:
                return {"result": "WIN", "exit": tp3, "bars": i - start_i}
        else:  # SHORT
            if high >= sl:
                return {"result": "LOSS", "exit": sl, "bars": i - start_i}
            if low <= tp3:
                return {"result": "WIN", "exit": tp3, "bars": i - start_i}

    return {"result": "OPEN", "exit": None, "bars": len(df) - start_i}


def _get_scenarios(sub: pd.DataFrame, macro_trend: str, rsi14: float, is_vol_spike: bool) -> List[Dict]:
    """pivot → build_scenarios → context_gate → คืน gated scenarios"""
    pivots = find_fractal_pivots(sub)
    pivots = filter_pivots(pivots, min_pct_move=1.5)
    if len(pivots) < 4:
        return []

    scenarios = build_scenarios(
        pivots,
        macro_trend=macro_trend,
        rsi14=rsi14,
        volume_spike=is_vol_spike,
    )
    if not scenarios:
        return []

    regime = detect_market_regime(sub)
    macro_bias = compute_macro_bias(regime, rsi14=rsi14)

    gated: List[Dict] = []
    for sc in scenarios:
        r = apply_context_gate(sc, macro_bias=macro_bias, min_confidence=MIN_CONFIDENCE_BACKTEST)
        if r:
            gated.append(r)

    return gated


def _r_multiple(direction: str, entry: float, sl: float, tp3: float, result: str) -> float:
    """คิดผลเป็นหน่วย R: LOSS=-1R, WIN=+RR, OPEN=0"""
    risk = abs(entry - sl)
    if risk <= 0:
        return 0.0
    rr_tp3 = abs(tp3 - entry) / risk
    if result == "LOSS":
        return -1.0
    if result == "WIN":
        return float(rr_tp3)
    return 0.0


def _bucket_stats(trades: List[Dict], min_conf: float) -> Dict:
    bucket = [t for t in trades if float(t.get("confidence") or 0) >= min_conf]
    w = sum(1 for t in bucket if t["result"] == "WIN")
    l = sum(1 for t in bucket if t["result"] == "LOSS")
    o = sum(1 for t in bucket if t["result"] == "OPEN")
    closed = w + l
    wr = round((w / closed) * 100, 2) if closed > 0 else 0.0
    return {"trades": len(bucket), "wins": w, "losses": l, "open": o, "winrate": wr}


def _safe_entry_time(t: Dict):
    """sort key ที่กัน NaT/None ไม่ให้ TypeError"""
    v = t.get("entry_time")
    if v is None or (isinstance(v, float) and pd.isna(v)):
        return pd.Timestamp.min.tz_localize("UTC")
    if isinstance(v, pd.Timestamp) and pd.isna(v):
        return pd.Timestamp.min.tz_localize("UTC")
    return v


# ---------------------------------------------------------------------------
# backtest_symbol
# ---------------------------------------------------------------------------

def backtest_symbol(
    symbol: str,
    interval: str = "1d",
    limit: int = 1000,
    min_pct_move: float = 1.5,
    min_rr: float = 2.0,
) -> Dict:
    """
    Backtest แบบง่าย (summary stats เท่านั้น):
    - ทุกแท่งที่ผ่าน filter → เปิด 1 เทรด (ไม่ซ้อน)
    - จบเมื่อ SL หรือ TP3
    """
    _empty = {
        "symbol": symbol,
        "trades": 0,
        "wins": 0,
        "losses": 0,
        "open": 0,
        "winrate": 0.0,
        "conf_min": 0.0,
        "conf_max": 0.0,
        "conf_avg": 0.0,
        "buckets": _EMPTY_BUCKETS,
    }

    df = _prepare_df(symbol, interval, limit)
    if df is None:
        return _empty

    trades: List[Dict] = []
    in_position = False
    skip_until_bar = 0

    for i in range(_START_BAR, len(df) - 1):
        if in_position or i < skip_until_bar:
            continue

        sub = df.iloc[: i + 1].copy()
        macro_trend = trend_filter_ema(sub)
        rsi14 = float(sub["rsi14"].iloc[-1])
        is_vol_spike = bool(volume_spike(sub, length=20, multiplier=1.5))
        last_close = float(sub["close"].iloc[-1])

        scenarios = _get_scenarios(sub, macro_trend, rsi14, is_vol_spike)
        if not scenarios:
            continue

        sc = scenarios[0]
        direction = sc["direction"]

        # filters
        if not allow_direction(macro_trend, direction):
            continue
        if direction == "LONG" and rsi14 < 50:
            continue
        if direction == "SHORT" and rsi14 > 50:
            continue

        trade_plan = build_trade_plan(sc, current_price=last_close, min_rr=min_rr)
        if not trade_plan.get("valid"):
            continue

        entry = float(trade_plan["entry"])

        # ABC entry = current_price → triggered ทันที
        # IMPULSE entry = breakout price → เช็คปกติ
        stype = (sc.get("type") or "").upper()
        if stype == "ABC_UP":
            # LONG: ราคาปิดยืนเหนือ SL + 1% = momentum จริง
            triggered = last_close > float(trade_plan["sl"]) * 1.01
        elif stype == "ABC_DOWN":
            # SHORT: ราคาปิดต่ำกว่า SL - 1% = momentum จริง
            triggered = last_close < float(trade_plan["sl"]) * 0.99
        else:
            triggered = (
                (direction == "LONG" and last_close > entry)
                or (direction == "SHORT" and last_close < entry)
            )
        if not triggered:
            continue

        in_position = True

        sim = _simulate_one_trade(
            df=df,
            start_i=i + 1,
            direction=direction,
            entry=entry,
            sl=float(trade_plan["sl"]),
            tp1=float(trade_plan["tp1"]),
            tp2=float(trade_plan["tp2"]),
            tp3=float(trade_plan["tp3"]),
        )

        trades.append({
            "symbol": symbol,
            "bar_index": i,
            "direction": direction,
            "entry": entry,
            "sl": float(trade_plan["sl"]),
            "tp3": float(trade_plan["tp3"]),
            "confidence": float(sc.get("confidence") or sc.get("score") or 0),
            "result": sim["result"],
            "bars_held": sim["bars"],
        })

        logger.debug(
            "bar=%d dir=%s conf=%.1f result=%s",
            i, direction, trades[-1]["confidence"], sim["result"],
        )

        if sim["result"] in ("WIN", "LOSS"):
            in_position = False
        else:
            skip_until_bar = (i + 1) + int(sim["bars"])

    wins = sum(1 for t in trades if t["result"] == "WIN")
    losses = sum(1 for t in trades if t["result"] == "LOSS")
    opens = sum(1 for t in trades if t["result"] == "OPEN")
    total_closed = wins + losses
    winrate = round((wins / total_closed) * 100, 2) if total_closed > 0 else 0.0

    conf_values = [float(t.get("confidence") or 0) for t in trades]
    conf_min = round(min(conf_values), 2) if conf_values else 0.0
    conf_max = round(max(conf_values), 2) if conf_values else 0.0
    conf_avg = round(sum(conf_values) / len(conf_values), 2) if conf_values else 0.0

    return {
        "symbol": symbol,
        "trades": len(trades),
        "wins": wins,
        "losses": losses,
        "open": opens,
        "winrate": winrate,
        "conf_min": conf_min,
        "conf_max": conf_max,
        "conf_avg": conf_avg,
        "buckets": {
            "conf>=60": _bucket_stats(trades, 60),
            "conf>=70": _bucket_stats(trades, 70),
            "conf>=80": _bucket_stats(trades, 80),
        },
    }


# ---------------------------------------------------------------------------
# backtest_symbol_trades
# ---------------------------------------------------------------------------

def backtest_symbol_trades(
    symbol: str,
    interval: str = "1d",
    limit: int = 1000,
    min_pct_move: float = 1.5,
    min_rr: float = 2.0,
    min_confidence: float = 0.0,
) -> Dict:
    """
    เหมือน backtest_symbol แต่คืน trades list พร้อม entry/exit time + R multiple
    ใช้สำหรับ portfolio_simulator
    """
    df = _prepare_df(symbol, interval, limit)
    if df is None:
        return {"symbol": symbol, "trades": []}

    trades: List[Dict] = []
    in_position = False
    skip_until_bar = 0

    for i in range(_START_BAR, len(df) - 1):
        if in_position or i < skip_until_bar:
            continue

        sub = df.iloc[: i + 1].copy()
        macro_trend = trend_filter_ema(sub)
        rsi14 = float(sub["rsi14"].iloc[-1])
        is_vol_spike = bool(volume_spike(sub, length=20, multiplier=1.5))
        last_close = float(sub["close"].iloc[-1])

        scenarios = _get_scenarios(sub, macro_trend, rsi14, is_vol_spike)
        if not scenarios:
            continue

        sc = scenarios[0]
        direction = sc["direction"]

        # filters
        if not allow_direction(macro_trend, direction):
            continue
        if direction == "LONG" and rsi14 < 50:
            continue
        if direction == "SHORT" and rsi14 > 50:
            continue

        conf = float(sc.get("confidence") or sc.get("score") or 0)
        if conf < float(min_confidence):
            continue

        trade_plan = build_trade_plan(sc, current_price=last_close, min_rr=min_rr)
        if not trade_plan.get("valid"):
            continue

        entry = float(trade_plan["entry"])

        # ABC entry = current_price → triggered ทันที
        # IMPULSE entry = breakout price → เช็คปกติ
        stype = (sc.get("type") or "").upper()
        if stype == "ABC_UP":
            # LONG: ราคาปิดยืนเหนือ SL + 1% = momentum จริง
            triggered = last_close > float(trade_plan["sl"]) * 1.01
        elif stype == "ABC_DOWN":
            # SHORT: ราคาปิดต่ำกว่า SL - 1% = momentum จริง
            triggered = last_close < float(trade_plan["sl"]) * 0.99
        else:
            triggered = (
                (direction == "LONG" and last_close > entry)
                or (direction == "SHORT" and last_close < entry)
            )
        if not triggered:
            continue

        in_position = True
        start_i = i + 1

        sim = _simulate_one_trade(
            df=df,
            start_i=start_i,
            direction=direction,
            entry=entry,
            sl=float(trade_plan["sl"]),
            tp1=float(trade_plan["tp1"]),
            tp2=float(trade_plan["tp2"]),
            tp3=float(trade_plan["tp3"]),
        )

        # exit time
        exit_index: Optional[int] = None
        exit_time = None
        if sim["result"] in ("WIN", "LOSS"):
            exit_index = start_i + int(sim["bars"])
            if 0 <= exit_index < len(df):
                exit_time = df["open_time"].iloc[exit_index]

        entry_time = df["open_time"].iloc[i]
        r = _r_multiple(direction, entry, float(trade_plan["sl"]), float(trade_plan["tp3"]), sim["result"])

        trades.append({
            "symbol": symbol,
            "entry_index": i,
            "entry_time": entry_time,
            "exit_index": exit_index,
            "exit_time": exit_time,
            "direction": direction,
            "confidence": conf,
            "entry": entry,
            "sl": float(trade_plan["sl"]),
            "tp3": float(trade_plan["tp3"]),
            "result": sim["result"],
            "r_multiple": r,
        })

        if sim["result"] in ("WIN", "LOSS"):
            in_position = False
        else:
            skip_until_bar = (i + 1) + int(sim["bars"])

    return {"symbol": symbol, "trades": trades}


# ---------------------------------------------------------------------------
# portfolio_simulator
# ---------------------------------------------------------------------------

def portfolio_simulator(
    symbols: List[str],
    interval: str = "1d",
    limit: int = 1000,
    min_pct_move: float = 1.5,
    min_rr: float = 2.0,
    min_confidence: float = 60.0,
) -> Dict:
    """
    Portfolio simulator:
    - รวมเทรดของทุกเหรียญ filtered ด้วย min_confidence
    - sort ตาม entry_time (✅ FIX: กัน NaT crash)
    - คิด equity R + Max Drawdown
    """
    all_trades: List[Dict] = []

    for s in symbols:
        res = backtest_symbol_trades(
            s,
            interval=interval,
            limit=limit,
            min_pct_move=min_pct_move,
            min_rr=min_rr,
            min_confidence=min_confidence,
        )
        all_trades.extend(res["trades"])

    # ✅ FIX: ใช้ _safe_entry_time กัน NaT/None TypeError ตอน sort
    all_trades.sort(key=_safe_entry_time)

    closed = [t for t in all_trades if t["result"] in ("WIN", "LOSS")]
    wins = sum(1 for t in closed if t["result"] == "WIN")
    losses = sum(1 for t in closed if t["result"] == "LOSS")
    total = len(closed)
    winrate = round((wins / total) * 100, 2) if total > 0 else 0.0

    equity = 0.0
    peak = 0.0
    max_dd = 0.0
    curve: List[float] = []

    for t in closed:
        equity += float(t["r_multiple"])
        peak = max(peak, equity)
        dd = peak - equity
        max_dd = max(max_dd, dd)
        curve.append(equity)

    return {
        "symbols": symbols,
        "min_confidence": float(min_confidence),
        "trades": total,
        "wins": wins,
        "losses": losses,
        "winrate": winrate,
        "equity_R": round(equity, 2),
        "max_drawdown_R": round(max_dd, 2),
    }


# ---------------------------------------------------------------------------
# __main__
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)

    symbols = ["BTCUSDT", "XRPUSDT", "ADAUSDT", "BNBUSDT", "TRXUSDT", "DOGEUSDT"]

    res = portfolio_simulator(symbols, interval="1d", limit=1000, min_confidence=60)
    print(res)

    res2 = portfolio_simulator(symbols, interval="1d", limit=1000, min_confidence=70)
    print(res2)
===== app/config/wave_settings.py =====
from zoneinfo import ZoneInfo

TIMEFRAME = "1d"
BARS = 1000

TIMEZONE = ZoneInfo("Asia/Bangkok")
RUN_HOUR = 7
RUN_MINUTE = 5

SYMBOLS = [
    "BTCUSDT",
    "ETHUSDT",
    "BNBUSDT",
    "SOLUSDT",
    "XRPUSDT",
    "ADAUSDT",
    "DOGEUSDT",
    "TRXUSDT",
    "TONUSDT",
    "AVAXUSDT",
    "DOTUSDT",
    "LINKUSDT",
    "LTCUSDT",
    "ATOMUSDT",
    "UNIUSDT",
    "NEARUSDT",
    "APTUSDT",
    "ICPUSDT",
    "FILUSDT",
    "ARBUSDT",
]

FRACTAL_LEFT = 2
FRACTAL_RIGHT = 2

MAX_SCENARIOS = 3
MIN_RR = 2.0
MIN_CONFIDENCE_LIVE = 70.0
MIN_CONFIDENCE_BACKTEST = 55

MAX_RETRY = 3
===== app/data/__init__.py =====

===== app/data/binance_fetcher.py =====
import logging
import time

import pandas as pd
import requests

logger = logging.getLogger(__name__)

BASE_URL = "https://api.binance.com/api/v3/klines"
_MAX_RETRY = 3
_RETRY_DELAY = 5  # วินาที


def fetch_ohlcv(symbol: str, interval: str = "1d", limit: int = 1000) -> pd.DataFrame:
    params = {
        "symbol": symbol,
        "interval": interval,
        "limit": limit,
    }

    last_error = None

    for attempt in range(1, _MAX_RETRY + 1):
        try:
            response = requests.get(BASE_URL, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()

            df = pd.DataFrame(
                data,
                columns=[
                    "open_time", "open", "high", "low", "close", "volume",
                    "close_time", "qav", "num_trades",
                    "taker_base_vol", "taker_quote_vol", "ignore",
                ],
            )

            df["open_time"] = pd.to_datetime(df["open_time"], unit="ms", utc=True)
            df["close_time"] = pd.to_datetime(df["close_time"], unit="ms", utc=True)

            for col in ["open", "high", "low", "close", "volume"]:
                df[col] = df[col].astype(float)

            return df[["open_time", "open", "high", "low", "close", "volume"]]

        except requests.exceptions.Timeout:
            last_error = "timeout"
            logger.warning(f"[{symbol}] fetch timeout attempt={attempt}/{_MAX_RETRY}")

        except requests.exceptions.ConnectionError:
            last_error = "connection error"
            logger.warning(f"[{symbol}] connection error attempt={attempt}/{_MAX_RETRY}")

        except requests.exceptions.HTTPError as e:
            last_error = str(e)
            logger.warning(f"[{symbol}] HTTP error {e} attempt={attempt}/{_MAX_RETRY}")

        except Exception as e:
            last_error = str(e)
            logger.error(f"[{symbol}] unexpected error {e} attempt={attempt}/{_MAX_RETRY}")

        if attempt < _MAX_RETRY:
            time.sleep(_RETRY_DELAY)

    logger.error(f"[{symbol}] fetch_ohlcv ล้มเหลวทุก {_MAX_RETRY} ครั้ง: {last_error}")
    return pd.DataFrame()


def drop_unclosed_candle(df: pd.DataFrame) -> pd.DataFrame:
    if df is None or len(df) < 2:
        return df

    try:
        last_open = df["open_time"].iloc[-1]
        prev_open = df["open_time"].iloc[-2]
        interval = last_open - prev_open
        expected_close = last_open + interval
        now = pd.Timestamp.now(tz="UTC")

        if now < expected_close:
            return df.iloc[:-1].copy()

        return df.copy()

    except Exception as e:
        logger.error(f"drop_unclosed_candle error: {e}")
        return df.copy()

===== app/indicators/__init__.py =====

===== app/indicators/atr.py =====
import pandas as pd


def atr(df: pd.DataFrame, length: int = 14) -> pd.Series:
    """
    ATR (Wilder)
    expects columns: high, low, close
    """

    high = df["high"]
    low = df["low"]
    close = df["close"]

    prev_close = close.shift(1)

    tr1 = high - low
    tr2 = (high - prev_close).abs()
    tr3 = (low - prev_close).abs()

    true_range = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

    return true_range.ewm(alpha=1 / length, adjust=False).mean()


def add_atr(df: pd.DataFrame, length: int = 14) -> pd.DataFrame:
    out = df.copy()
    out[f"atr{length}"] = atr(out, length)
    return out
    
===== app/indicators/ema.py =====
import pandas as pd


def ema(series: pd.Series, length: int) -> pd.Series:
    """
    Exponential Moving Average (EMA)
    """
    return series.ewm(span=length, adjust=False).mean()


def add_ema(df: pd.DataFrame, lengths=(50, 200)) -> pd.DataFrame:
    """
    Add EMA columns to df
    - expects df has 'close'
    """
    out = df.copy()
    for L in lengths:
        out[f"ema{L}"] = ema(out["close"], L)
    return out
===== app/indicators/rsi.py =====
import pandas as pd


def rsi(close: pd.Series, length: int = 14) -> pd.Series:
    """
    RSI (Wilder)
    """
    delta = close.diff()

    gain = delta.where(delta > 0, 0.0)
    loss = (-delta).where(delta < 0, 0.0)

    avg_gain = gain.ewm(alpha=1 / length, adjust=False).mean()
    avg_loss = loss.ewm(alpha=1 / length, adjust=False).mean()

    rs = avg_gain / avg_loss.replace(0, 1e-12)
    out = 100 - (100 / (1 + rs))
    return out


def add_rsi(df: pd.DataFrame, length: int = 14) -> pd.DataFrame:
    """
    Add RSI column to df
    - expects df has 'close'
    """
    out = df.copy()
    out[f"rsi{length}"] = rsi(out["close"], length)
    return out
    
===== app/indicators/trend_filter.py =====
import pandas as pd


def trend_filter_ema(df: pd.DataFrame) -> str:
    """
    Trend filter using EMA50/EMA200
    expects columns: ema50, ema200, close

    returns: "BULL", "BEAR", "NEUTRAL"
    """
    if "ema50" not in df.columns or "ema200" not in df.columns:
        return "NEUTRAL"

    close = df["close"].iloc[-1]
    ema50 = df["ema50"].iloc[-1]
    ema200 = df["ema200"].iloc[-1]

    if pd.isna(ema50) or pd.isna(ema200):
        return "NEUTRAL"

    if close > ema50 > ema200:
        return "BULL"
    if close < ema50 < ema200:
        return "BEAR"
    return "NEUTRAL"


def allow_direction(macro_trend: str, direction: str) -> bool:
    """
    Allow trade direction based on macro trend
    - BULL: allow LONG
    - BEAR: allow SHORT
    - NEUTRAL: allow both but treat as lower confidence
    """
    macro_trend = (macro_trend or "").upper()
    direction = (direction or "").upper()

    if macro_trend == "BULL":
        return direction == "LONG"
    if macro_trend == "BEAR":
        return direction == "SHORT"
    return True
===== app/indicators/volume.py =====
import pandas as pd


def add_volume_ma(df: pd.DataFrame, length: int = 20) -> pd.DataFrame:
    """
    Add Volume Moving Average
    expects column: volume
    """

    out = df.copy()
    out[f"vol_ma{length}"] = out["volume"].rolling(length).mean()
    return out


def volume_spike(df: pd.DataFrame, length: int = 20, multiplier: float = 1.5) -> bool:
    """
    Check if latest volume > multiplier × volume MA
    """

    if len(df) < length + 1:
        return False

    vol = df["volume"].iloc[-1]
    vol_ma = df[f"vol_ma{length}"].iloc[-1]

    if pd.isna(vol_ma):
        return False

    return vol > vol_ma * multiplier
===== app/main.py =====
import sys
import os
from dotenv import load_dotenv
load_dotenv()

from flask import Flask, request
from app.scheduler.daily_wave_scheduler import run_daily_wave_job, run_trend_watch_job

app = Flask(__name__)

@app.route("/")
def health():
    return "OK", 200

@app.route("/trend-watch", methods=["POST"])
def trend_watch():
    run_trend_watch_job(min_conf=65.0)
    return "OK", 200

@app.route("/run-daily", methods=["POST"])
def run_daily():
    expected = (os.getenv("CRON_TOKEN") or "").strip()
    got = (request.headers.get("X-CRON-TOKEN") or "").strip()
    if expected and got != expected:
        return "FORBIDDEN", 403

    run_daily_wave_job()
    return "OK", 200

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "run":
        print("Manual Run Mode...")
        run_daily_wave_job()

    elif len(sys.argv) > 1 and sys.argv[1] == "trend-watch":
        print("Manual Trend Watch Mode...")
        run_trend_watch_job(min_conf=65.0)

    else:
        app.run(host="0.0.0.0", port=8080)
===== app/risk/__init__.py =====

===== app/risk/risk_manager.py =====
from __future__ import annotations

import logging
from typing import Dict, Optional

from app.analysis.fib import fib_extension

logger = logging.getLogger(__name__)


def calculate_rr(entry: float, sl: float, tp: float) -> float:
    risk = abs(entry - sl)
    reward = abs(tp - entry)
    if risk == 0:
        return 0.0
    return reward / risk


def _safe_fib_extension(p0: float, p1: float, anchor: float, direction: str, base_len: float) -> Dict:
    """
    คำนวณ fib_extension แบบปลอดภัย
    ถ้า p0 == p1 หรือผลออกมาผิดทิศ → fallback คำนวณจาก base_len แทน
    """
    try:
        if abs(p1 - p0) > 0:
            targets = fib_extension(p0, p1, anchor)
            t1 = float(targets["1.0"])
            t2 = float(targets["1.618"])
            t3 = float(targets["2.0"])

            # ตรวจสอบว่า TP ถูกทิศไหม
            if direction == "LONG" and t1 > anchor and t2 > t1 and t3 > t2:
                return {"1.0": t1, "1.618": t2, "2.0": t3}
            if direction == "SHORT" and t1 < anchor and t2 < t1 and t3 < t2:
                return {"1.0": t1, "1.618": t2, "2.0": t3}

            logger.warning(f"fib_extension ผิดทิศ direction={direction} t1={t1} anchor={anchor} → fallback")

    except Exception as e:
        logger.warning(f"fib_extension error: {e} → fallback")

    # fallback: คำนวณจาก base_len
    if direction == "LONG":
        return {
            "1.0": anchor + base_len * 1.0,
            "1.618": anchor + base_len * 1.618,
            "2.0": anchor + base_len * 2.0,
        }
    return {
        "1.0": anchor - base_len * 1.0,
        "1.618": anchor - base_len * 1.618,
        "2.0": anchor - base_len * 2.0,
    }


def build_trade_plan(
    scenario: Dict,
    current_price: float,
    min_rr: float = 2.0,
    sr: Optional[Dict] = None,
) -> Dict:
    stype = (scenario.get("type") or "").upper()
    direction = (scenario.get("direction") or "").upper()

    trade = {
        "direction": direction,
        "entry": None,
        "sl": None,
        "tp1": None,
        "tp2": None,
        "tp3": None,
        "valid": False,
        "reason": "",
    }

    # =========================
    # SIDEWAY_RANGE
    # =========================
    if stype == "SIDEWAY_RANGE":
        range_low = float(scenario.get("range_low") or 0)
        range_high = float(scenario.get("range_high") or 0)
        atr = float(scenario.get("atr") or current_price * 0.01)

        if range_low <= 0 or range_high <= range_low:
            trade["reason"] = "SIDEWAY: range ไม่ valid"
            return trade

        span = range_high - range_low

        if direction == "LONG":
            entry = float(current_price)
            sl = range_low - atr * 0.5
            tp1 = range_low + span * 0.382
            tp2 = range_low + span * 0.618
            tp3 = range_high - atr * 0.3
        elif direction == "SHORT":
            entry = float(current_price)
            sl = range_high + atr * 0.5
            tp1 = range_high - span * 0.382
            tp2 = range_high - span * 0.618
            tp3 = range_low + atr * 0.3
        else:
            trade["reason"] = "SIDEWAY: direction ไม่ถูกต้อง"
            return trade

        rr = calculate_rr(entry, sl, tp2)
        if rr >= min_rr:
            trade.update({
                "entry": entry, "sl": sl,
                "tp1": tp1, "tp2": tp2, "tp3": tp3,
                "valid": True,
                "reason": f"RR={round(rr, 2)} ≥ {min_rr}",
            })
        else:
            trade["reason"] = f"RR ต่ำ ({round(rr, 2)})"
        return trade

    # =========================
    # ABC
    # =========================
    if stype in ("ABC_DOWN", "ABC_UP"):
        pivots = scenario.get("pivots") or []
        if len(pivots) < 3:
            trade["reason"] = "ABC: pivots ไม่พอ"
            return trade

        if stype == "ABC_DOWN":
            h0 = float(pivots[0]["price"])
            l1 = float(pivots[1]["price"])
            h2 = float(pivots[2]["price"])
            a_len = abs(h0 - l1)
            if current_price >= h2:
                trade["reason"] = "ABC_DOWN: ราคาเหนือ SL แล้ว (invalid)"
                return trade

            entry = float(current_price)
            sl = h2

            fib = _safe_fib_extension(h0, l1, entry, "SHORT", a_len)
            tp1, tp2, tp3 = fib["1.0"], fib["1.618"], fib["2.0"]

            if sr:
                resist = (sr.get("resist") or {}).get("level")
                if resist and float(resist) < sl:
                    sl = float(resist)

        else:  # ABC_UP
            l0 = float(pivots[0]["price"])
            h1 = float(pivots[1]["price"])
            l2 = float(pivots[2]["price"])
            a_len = abs(h1 - l0)
            if current_price <= l2:
                trade["reason"] = "ABC_UP: ราคาต่ำกว่า SL แล้ว (invalid)"
                return trade

            entry = float(current_price)
            sl = l2

            fib = _safe_fib_extension(l0, h1, entry, "LONG", a_len)
            tp1, tp2, tp3 = fib["1.0"], fib["1.618"], fib["2.0"]

            if sr:
                support = (sr.get("support") or {}).get("level")
                if support and float(support) > sl:
                    sl = float(support)

        rr = calculate_rr(entry, sl, tp2)
        if rr >= min_rr:
            trade.update({
                "entry": entry, "sl": sl,
                "tp1": tp1, "tp2": tp2, "tp3": tp3,
                "valid": True,
                "reason": f"RR={round(rr, 2)} ≥ {min_rr} (fib+sr)",
            })
        else:
            trade["reason"] = f"RR ต่ำ ({round(rr, 2)})"
        return trade

    # =========================
    # IMPULSE
    # =========================
    pivots = scenario.get("pivots") or []
    if len(pivots) < 2:
        trade["reason"] = "IMPULSE: pivots ไม่พอ"
        return trade

    breakout = float(pivots[-1]["price"])
    sl = float(pivots[-2]["price"])
    entry = breakout
    p0 = float(pivots[0]["price"])
    p1 = float(pivots[1]["price"])
    base_len = abs(p1 - p0)

    fib = _safe_fib_extension(p0, p1, entry, direction, base_len)
    tp1, tp2, tp3 = fib["1.0"], fib["1.618"], fib["2.0"]

    if direction == "LONG":
        if sr:
            support = (sr.get("support") or {}).get("level")
            if support and float(support) > sl:
                sl = float(support)
    elif direction == "SHORT":
        if sr:
            resist = (sr.get("resist") or {}).get("level")
            if resist and float(resist) < sl:
                sl = float(resist)
    else:
        trade["reason"] = "IMPULSE: direction ไม่ถูกต้อง"
        return trade

    rr = calculate_rr(entry, sl, tp2)
    if rr >= min_rr:
        trade.update({
            "entry": entry, "sl": sl,
            "tp1": tp1, "tp2": tp2, "tp3": tp3,
            "valid": True,
            "reason": f"RR={round(rr, 2)} ≥ {min_rr} (fib+sr)",
        })
    else:
        trade["reason"] = f"RR ต่ำ ({round(rr, 2)})"

    return trade

===== app/scheduler/__init__.py =====

===== app/scheduler/daily_wave_scheduler.py =====
import time
import os
from datetime import datetime

from app.config.wave_settings import (
    SYMBOLS,
    RUN_HOUR,
    RUN_MINUTE,
    TIMEZONE,
    MAX_RETRY,
)
from app.analysis.wave_engine import analyze_symbol
from app.state.position_manager import get_active, lock_new_position, update_from_price
from app.config.wave_settings import TIMEFRAME
from app.services.telegram_reporter import format_symbol_report, send_message

def _fmt_price(x: float) -> str:
    x = float(x)
    return f"{x:,.5f}" if x < 1 else f"{x:,.2f}"

def run_daily_wave_job():
    print(f"=== START DAILY WAVE JOB | tf={TIMEFRAME} | symbols={len(SYMBOLS)} ===", flush=True)

    found = 0
    found_symbols = []
    errors = 0

    for symbol in SYMBOLS:
        print(f"[{symbol}] start", flush=True)
        retry = 0

        while retry < MAX_RETRY:
            try:
                analysis = analyze_symbol(symbol)
                if not analysis:
                    print(f"[{symbol}] no analysis -> skip", flush=True)
                    break

                active = get_active(symbol, TIMEFRAME)
                if active:
                    pos, events = update_from_price(
                        symbol,
                        TIMEFRAME,
                        float(analysis["price"])
                    )
                    break

                scenarios = analysis.get("scenarios", []) or []
                sent = False

                for sc in scenarios:
                    trade = sc.get("trade_plan", {}) or {}

                    if not trade.get("valid"):
                        continue

                    if trade.get("triggered") is not True:
                        continue

                    ok = lock_new_position(
                        symbol=symbol,
                        timeframe=TIMEFRAME,
                        direction=sc.get("direction", ""),
                        trade_plan=trade,
                    )

                    if not ok:
                        continue

                    text = format_symbol_report(analysis)
                    send_message(text)

                    print(f"[{symbol}] SENT signal", flush=True)

                    found += 1
                    found_symbols.append(symbol)
                    sent = True
                    break

                if not sent:
                    wl = (analysis.get("wave_label", {}) or {}).get("label", {}) or {}
                    print(
                        f"[{symbol}] no triggered signal | "
                        f"wave={wl.get('pattern')} "
                        f"{wl.get('direction')} "
                        f"conf={wl.get('confidence')}",
                        flush=True
                    )

                break

            except Exception as e:
                retry += 1
                print(f"[{symbol}] ERROR retry={retry}/{MAX_RETRY}: {e}", flush=True)
                if retry >= MAX_RETRY:
                    errors += 1
                    break
                time.sleep(2)

    # ✅ สรุปเช้า: เจอ/ไม่เจอ
    summary = []
    summary.append(f"🕖 DAILY SUMMARY ({TIMEFRAME.upper()})")
    summary.append(f"สแกน: {len(SYMBOLS)} เหรียญ")
    summary.append(f"พบสัญญาณ: {found} เหรียญ")
    summary.append(f"ไม่พบสัญญาณ: {len(SYMBOLS) - found} เหรียญ")
    if found_symbols:
        summary.append("รายการที่พบ: " + ", ".join(found_symbols))
    if errors:
        summary.append(f"⚠️ errors: {errors}")

    send_message("\n".join(summary), topic_id=os.getenv("TOPIC_NORMAL_ID"))

    print("=== END DAILY WAVE JOB ===", flush=True)
    
def run_trend_watch_job(min_conf: float = 65.0):
    """
    Trend Watch (19:00): ใช้ 1D scenarios (ไม่ต้อง triggered)
    - ไม่ lock position
    - ไม่ update position
    - แจ้งเฉพาะเหรียญที่ confidence >= min_conf
    """
    print(f"=== START TREND WATCH | tf={TIMEFRAME} | min_conf={min_conf} ===", flush=True)

    picks = []
    errors = 0

    for symbol in SYMBOLS:
        retry = 0
        while retry < MAX_RETRY:
            try:
                analysis = analyze_symbol(symbol)
                if not analysis:
                    break

                scenarios = analysis.get("scenarios", []) or []
                if not scenarios:
                    break

                # ใช้ scenario อันดับ 1 (คะแนนสูงสุดใน wave_engine)
                sc = scenarios[0]
                conf = float(sc.get("confidence") or 0)
                if conf < float(min_conf):
                    break

                direction = (sc.get("direction") or "-").upper()
                price = float(analysis.get("price") or 0)

                trade = sc.get("trade_plan", {}) or {}
                entry = trade.get("entry")
                entry = float(entry) if entry is not None else None

                # ระยะห่างถึง entry (%)
                dist = None
                if entry and price:
                    dist = abs((entry - price) / price) * 100.0

                picks.append({
                    "symbol": symbol,
                    "direction": direction,
                    "confidence": conf,
                    "price": price,
                    "entry": entry,
                    "dist": dist,
                })
                break

            except Exception as e:
                retry += 1
                print(f"[{symbol}] TREND WATCH ERROR retry={retry}/{MAX_RETRY}: {e}", flush=True)
                if retry >= MAX_RETRY:
                    errors += 1
                    break
                time.sleep(1)

    # เรียง: conf มากก่อน แล้ว dist ใกล้ก่อน
    picks.sort(key=lambda x: (-x["confidence"], x["dist"] if x["dist"] is not None else 1e9))

    lines = []
    lines.append("📡 TREND WATCH (1D) — 19:00")
    lines.append(f"เกณฑ์: Conf >= {int(min_conf)} | จำนวนที่น่าจับตา: {len(picks)}")
    lines.append("")

    if not picks:
        lines.append("วันนี้ยังไม่มีเหรียญที่เข้าเกณฑ์ (รอดูแท่งปิด 1D ตามรอบปกติ)")
    else:
        # กันยาวเกิน: ส่งแค่ TOP 10
        top = picks[:10]
        for i, p in enumerate(top, start=1):
            sym = p["symbol"]
            d = p["direction"]
            conf = round(p["confidence"], 1)
            price = p["price"]
            entry = p["entry"]
            dist = p["dist"]

            if entry is not None and dist is not None:
                lines.append(f"{i}) {sym} {d} | Conf {conf} | ราคา {_fmt_price(price)} | Entry {_fmt_price(entry)} | ห่าง {dist:.2f}%")
            else:
                lines.append(f"{i}) {sym} {d} | Conf {conf} | ราคา {_fmt_price(price)}")

        if len(picks) > 10:
            lines.append("")
            lines.append(f"…และมีอีก {len(picks) - 10} เหรียญที่เข้าเกณฑ์")

    if errors:
        lines.append("")
        lines.append(f"⚠️ errors: {errors}")

    send_message("\n".join(lines), topic_id=os.getenv("TOPIC_NORMAL_ID"))
    print("=== END TREND WATCH ===", flush=True)

def start_scheduler_loop():
    """
    Loop เช็คเวลา 20:00 ไทย แล้วรันวันละครั้ง
    """
    print("Wave Scheduler Started...")

    while True:
        now = datetime.now(TIMEZONE)

        if now.hour == RUN_HOUR and now.minute == RUN_MINUTE:
            run_daily_wave_job()
            time.sleep(60)  # กันรันซ้ำในนาทีเดียวกัน

        time.sleep(20)
===== app/services/__init__.py =====

===== app/services/telegram_reporter.py =====
# app/services/telegram_reporter.py
import os
import requests


def _tg_api_url(method: str, token: str) -> str:
    return f"https://api.telegram.org/bot{token}/{method}"


def send_message(text: str, topic_id: str | int | None = None) -> None:
    TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "").strip()
    TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "").strip()

    # รองรับหลายชื่อ env
    TELEGRAM_TOPIC_ID = (os.getenv("TELEGRAM_TOPIC_ID") or "").strip()
    TELEGRAM_TOPIC_ID = TELEGRAM_TOPIC_ID.strip()

    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
        print("\n====== TELEGRAM PREVIEW ======")
        print(text)
        print("====== END PREVIEW ======\n")
        return

    payload = {
        "chat_id": TELEGRAM_CHAT_ID,
        "text": text,
        "disable_web_page_preview": True,
    }

    if topic_id is not None and str(topic_id).strip().isdigit():
        payload["message_thread_id"] = int(str(topic_id).strip())
    elif TELEGRAM_TOPIC_ID.isdigit():
        payload["message_thread_id"] = int(TELEGRAM_TOPIC_ID)

    print("TG_SEND chat_id=", TELEGRAM_CHAT_ID,
      "thread=", payload.get("message_thread_id"),
      flush=True)        

    r = requests.post(_tg_api_url("sendMessage", TELEGRAM_BOT_TOKEN), json=payload, timeout=15)
    r.raise_for_status()


def _fmt_price(x: float) -> str:
    x = float(x)
    return f"{x:,.5f}" if x < 1 else f"{x:,.2f}"


def format_symbol_report(analysis: dict) -> str:
    symbol = analysis.get("symbol", "-")
    price = analysis.get("price")
    macro = analysis.get("macro_trend")
    rsi14 = analysis.get("rsi14")
    vol = analysis.get("volume_spike")
    mtf = analysis.get("mtf") or {}
    mode = analysis.get("mode")
    size_mult = analysis.get("position_size_mult")

    wl = (analysis.get("wave_label") or {}).get("label") or {}
    pivots = wl.get("pivots") or []

    scenarios = analysis.get("scenarios", []) or []
    if not scenarios:
        return f"{symbol} — ไม่มีสัญญาณที่ผ่านเงื่อนไข"

    sc = scenarios[0]
    trade = sc.get("trade_plan", {}) or {}

    entry = trade.get("entry")
    sl = trade.get("sl")
    tp1 = trade.get("tp1")
    tp2 = trade.get("tp2")
    tp3 = trade.get("tp3")

    sr = analysis.get("sr") or {}
    support = (sr.get("support") or {}).get("level")
    resist = (sr.get("resist") or {}).get("level")

    # Pivot list format
    pivot_lines = []
    for i, p in enumerate(pivots, start=1):
        pivot_lines.append(
            f"{i}) {p.get('type')} { _fmt_price(p.get('price')) }"
        )

    pivot_text = "\n".join(pivot_lines) if pivot_lines else "-"

    text = f"""
════════════════════════════
👑 VIP รายงานเชิงลึก — {symbol} (1D)
อัปเดตเวลา 07:05 น.
════════════════════════════

📍 ราคาปัจจุบัน: {_fmt_price(price) if price else '-'}

📊 ภาพรวมตลาด
- แนวโน้มหลัก: {macro}
- สภาพตลาด: {mode}
- RSI14: {round(rsi14,1) if rsi14 else '-'}
- ปริมาณซื้อขายสูงผิดปกติ: {bool(vol)}

📚 มุมมองหลายไทม์เฟรม
- รายสัปดาห์: {mtf.get('weekly_trend')}
- 4 ชั่วโมงยืนยัน: {mtf.get('h4_confirm_long') or mtf.get('h4_confirm_short')}

────────────────────
🧠 โครงสร้าง Elliott Wave
รูปแบบล่าสุด: {wl.get('pattern')}

ลำดับจุดกลับตัว (Pivot)
{pivot_text}

────────────────────
🎯 แผนการเทรด
ทิศทาง: {sc.get('direction')}

เข้าเมื่อราคาปิดเหนือ: {_fmt_price(entry) if entry else '-'}
จุดตัดขาดทุน (SL): {_fmt_price(sl) if sl else '-'}

เป้าหมายกำไร:
TP1: {_fmt_price(tp1) if tp1 else '-'}
TP2: {_fmt_price(tp2) if tp2 else '-'}
TP3: {_fmt_price(tp3) if tp3 else '-'}

ขนาดไม้แนะนำ: {size_mult} เท่า

────────────────────
📌 แนวรับ / แนวต้านใกล้เคียง
แนวรับใกล้สุด: {_fmt_price(support) if support else '-'}
แนวต้านใกล้สุด: {_fmt_price(resist) if resist else '-'}

────────────────────
สถานะสัญญาณ: {"พร้อมเข้า (TRIGGERED)" if trade.get("triggered") else "รอการยืนยัน (WAIT)"}
ระบบจะปิดสถานะเมื่อ:
- ถึง SL หรือ
- ถึง TP3 เท่านั้น
════════════════════════════
""".strip()
    footer = "\n\n────────────────────\n🔵 SYSTEM: ELLIOTT-WAVE\nEngine: 1D\n"
    return text + footer
===== app/state/__init__.py =====

===== app/state/position_manager.py =====
import json
import logging
import sqlite3
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional, Tuple

logger = logging.getLogger(__name__)

# ✅ FIX: ใช้ SQLite แทน JSON file
DB_PATH = Path("positions.db")


def _get_conn() -> sqlite3.Connection:
    conn = sqlite3.connect(str(DB_PATH))
    conn.row_factory = sqlite3.Row
    return conn


def _init_db() -> None:
    with _get_conn() as conn:
        conn.execute("""
            CREATE TABLE IF NOT EXISTS positions (
                key TEXT PRIMARY KEY,
                data TEXT NOT NULL
            )
        """)
        conn.commit()


# เรียก init ตอน import
_init_db()


@dataclass
class Position:
    symbol: str
    timeframe: str
    direction: str
    entry: float
    sl: float
    tp1: float
    tp2: float
    tp3: float
    status: str
    tp1_hit: bool = False
    tp2_hit: bool = False
    tp3_hit: bool = False
    sl_hit: bool = False
    opened_at: str = ""
    closed_at: str = ""
    closed_reason: str = ""


def _now_iso() -> str:
    return datetime.utcnow().isoformat() + "Z"


def _key(symbol: str, timeframe: str) -> str:
    return f"{symbol}:{timeframe}".upper()


def _load_position(key: str) -> Optional[Dict]:
    try:
        with _get_conn() as conn:
            row = conn.execute(
                "SELECT data FROM positions WHERE key = ?", (key,)
            ).fetchone()
            if row:
                return json.loads(row["data"])
            return None
    except Exception as e:
        logger.error(f"_load_position {key} error: {e}")
        return None


def _save_position(key: str, data: Dict) -> None:
    try:
        with _get_conn() as conn:
            conn.execute(
                "INSERT OR REPLACE INTO positions (key, data) VALUES (?, ?)",
                (key, json.dumps(data, ensure_ascii=False))
            )
            conn.commit()
    except Exception as e:
        logger.error(f"_save_position {key} error: {e}")


def get_active(symbol: str, timeframe: str) -> Optional[Position]:
    try:
        k = _key(symbol, timeframe)
        raw = _load_position(k)
        if not raw:
            return None
        pos = Position(**raw)
        if pos.status == "ACTIVE":
            return pos
        return None
    except Exception as e:
        logger.error(f"get_active {symbol} error: {e}")
        return None


def lock_new_position(
    symbol: str, timeframe: str, direction: str, trade_plan: Dict
) -> bool:
    try:
        k = _key(symbol, timeframe)
        raw = _load_position(k)
        if raw and raw.get("status") == "ACTIVE":
            return False

        pos = Position(
            symbol=symbol,
            timeframe=timeframe,
            direction=direction,
            entry=float(trade_plan["entry"]),
            sl=float(trade_plan["sl"]),
            tp1=float(trade_plan["tp1"]),
            tp2=float(trade_plan["tp2"]),
            tp3=float(trade_plan["tp3"]),
            status="ACTIVE",
            opened_at=_now_iso(),
        )

        _save_position(k, asdict(pos))
        return True
    except Exception as e:
        logger.error(f"lock_new_position {symbol} error: {e}")
        return False


def update_from_price(
    symbol: str, timeframe: str, price: float
) -> Tuple[Optional[Position], Dict]:
    try:
        k = _key(symbol, timeframe)
        raw = _load_position(k)
        if not raw:
            return None, {}

        pos = Position(**raw)
        if pos.status != "ACTIVE":
            return pos, {}

        p = float(price)
        events = {
            "tp1": False, "tp2": False, "tp3": False,
            "sl": False, "closed": False, "closed_reason": ""
        }

        if pos.direction == "LONG":
            if (not pos.tp1_hit) and p >= pos.tp1:
                pos.tp1_hit = True
                events["tp1"] = True
            if (not pos.tp2_hit) and p >= pos.tp2:
                pos.tp2_hit = True
                events["tp2"] = True
            if (not pos.tp3_hit) and p >= pos.tp3:
                pos.tp3_hit = True
                events["tp3"] = True
            if (not pos.sl_hit) and p <= pos.sl:
                pos.sl_hit = True
                events["sl"] = True
        else:
            if (not pos.tp1_hit) and p <= pos.tp1:
                pos.tp1_hit = True
                events["tp1"] = True
            if (not pos.tp2_hit) and p <= pos.tp2:
                pos.tp2_hit = True
                events["tp2"] = True
            if (not pos.tp3_hit) and p <= pos.tp3:
                pos.tp3_hit = True
                events["tp3"] = True
            if (not pos.sl_hit) and p >= pos.sl:
                pos.sl_hit = True
                events["sl"] = True

        if pos.sl_hit and pos.status == "ACTIVE":
            pos.status = "CLOSED"
            pos.closed_at = _now_iso()
            pos.closed_reason = "SL"
            events["closed"] = True
            events["closed_reason"] = "SL"
        elif pos.tp3_hit and pos.status == "ACTIVE":
            pos.status = "CLOSED"
            pos.closed_at = _now_iso()
            pos.closed_reason = "TP3"
            events["closed"] = True
            events["closed_reason"] = "TP3"

        _save_position(k, asdict(pos))
        return pos, events

    except Exception as e:
        logger.error(f"update_from_price {symbol} error: {e}")
        return None, {}
